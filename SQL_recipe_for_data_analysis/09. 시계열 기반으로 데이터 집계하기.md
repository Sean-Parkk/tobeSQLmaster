# 09. 시계열 기반으로 데이터 집계하기
> WITH문을 이렇게 잘 쓸 수 있구나!

## 새로 알게된 것
### LAG(COL, n)
* 해당 레코드 n행 이전의 COL 데이터 가져오기
	* 전년 매출을 가져오는 데에 쓸 수 있구나!
### CTE
* 가독성을 향상
* 미드웨어에 따른 과금을 최소화
* 성능 최적화
* 등을 위해 많이 쓰이는구나. 효율적이다!
* 자주 사용하게 될 테이블은 따로 저장해놓는것도 좋은 듯.

## 쿼리
### 날짜별 매출 집계하기
```SQL
SELECT
	DT
    , COUNT(*) AS PURCHASE_COUNT
    , SUM(PURCHASE_AMOUNT) AS TOTAL_AMOUNT
    , AVG(PURCHASE_AMOUNT) AS AVG_AMOUNT
FROM PURCHASE_LOG
GROUP BY DT
ORDER BY DT;
```

### 이동평균을 사용한 날짜별 추이 보기
```SQL
SELECT
	DT,
    SUM(PURCHASE_AMOUNT) AS TOTAL_AMOUNT
    , AVG(SUM(PURCHASE_AMOUNT))
    OVER(ORDER BY DT ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS SEVEN_DAY_AVG
    , CASE
		-- 이 부분이 중요
        WHEN 7 = COUNT(*)
			OVER(ORDER BY DT ROWS BETWEEN 6 PRECEDING AND CURRENT ROW)
		THEN
			AVG(SUM(PURCHASE_AMOUNT))
            OVER(ORDER BY DT ROWS BETWEEN 6 PRECEDING AND CURRENT ROW)
		END AS SEVEN_DAY_AVG_AMOUNT_STRICT
FROM PURCHASE_LOG
GROUP BY DT
ORDER BY DT;
```

### 당월 매출 누계 구하기
```SQL
SELECT
	DT
	, SUBSTR(DT, 1, 7) AS YEAR_MONTH_
    , SUM(PURCHASE_AMOUNT) AS TOTAL_AMOUNT
	, SUM(SUM(PURCHASE_AMOUNT))
    OVER(PARTITION BY SUBSTR(DT, 1, 7) ORDER BY DT ROWS UNBOUNDED PRECEDING) AS AGG_AMOUNT
FROM PURCHASE_LOG
GROUP BY DT
ORDER BY DT;
```

### WITH문으로 가독성 높이기 (일시 테이블 만들기)
```SQL
WITH
DAILY_PURCHASE AS (
	SELECT
		DT
        , SUBSTR(DT, 1, 4) AS YEAR
        , SUBSTR(DT, 6, 2) AS MONTH
        , SUBSTR(DT, 9, 2) AS DATE
        , SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT
	FROM PURCHASE_LOG
    GROUP BY DT
    ORDER BY DT
)
SELECT * FROM DAILY_PURCHASE;
```

### WITH문으로 가독성 높이기
```SQL
WITH
DAILY_PURCHASE AS (
	SELECT
		DT
        , SUBSTR(DT, 1, 4) AS YEAR
        , SUBSTR(DT, 6, 2) AS MONTH
        , SUBSTR(DT, 9, 2) AS DATE
        , SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT
	FROM PURCHASE_LOG
    GROUP BY DT
    ORDER BY DT
)
SELECT
	DT
    , CONCAT(YEAR, '-', MONTH) AS YEAR_MONTH_
    , PURCHASE_AMOUNT
    , SUM(PURCHASE_AMOUNT)
    -- PARTITION BY 에서 컬럼 두개를 쉼표(,)로 묶을 수 있음
    OVER(PARTITION BY YEAR, MONTH ORDER BY DT ROWS UNBOUNDED PRECEDING) AS AGG_AMOUNT
FROM DAILY_PURCHASE;
```

### 월별 매출의 작대비 구하기
```SQL
WITH
DAILY_PURCHASE AS (
	SELECT
		DT
        , SUBSTR(DT, 1, 4) AS YEAR
        , SUBSTR(DT, 6, 2) AS MONTH
        , SUBSTR(DT, 9, 2) AS DATE
        , SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT
	FROM PURCHASE_LOG
    GROUP BY DT
    ORDER BY DT
)
SELECT
	MONTH
    , SUM(CASE WHEN YEAR = 2014 THEN PURCHASE_AMOUNT END) AS AMOUNT_2014
    , SUM(CASE WHEN YEAR = 2015 THEN PURCHASE_AMOUNT END) AS AMOUNT_2015
    , 100
	  * SUM(CASE WHEN YEAR = 2015 THEN PURCHASE_AMOUNT END)
      / SUM(CASE WHEN YEAR = 2014 THEN PURCHASE_AMOUNT END)
      AS RATE
FROM DAILY_PURCHASE
GROUP BY MONTH;
```

### Z차트로 업적의 추이 확인하기
```SQL
WITH
DAILY_PURCHASE AS (
	SELECT
		DT
        , SUBSTR(DT, 1, 4) AS YEAR
        , SUBSTR(DT, 6, 2) AS MONTH
        , SUBSTR(DT, 9, 2) AS DATE
        , SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT
	FROM PURCHASE_LOG
    GROUP BY DT
    ORDER BY DT
)
, MONTHLY_AMOUNT AS (
	SELECT
		YEAR
        , MONTH
        , SUM(PURCHASE_AMOUNT) AS AMOUNT
	FROM DAILY_PURCHASE
    GROUP BY YEAR, MONTH
)
, CALC_INDEX AS (
	SELECT
		YEAR
        , MONTH
        , AMOUNT
        , SUM(CASE WHEN YEAR = 2015 THEN AMOUNT END)
			OVER(ORDER BY YEAR, MONTH ROWS UNBOUNDED PRECEDING)
		AS AGG_AMOUNT
		, SUM(AMOUNT)
			OVER(ORDER BY YEAR, MONTH ROWS BETWEEN 11 PRECEDING AND CURRENT ROW)
		AS YEAR_AVG_AMOUNT
	FROM MONTHLY_AMOUNT
	ORDER BY YEAR, MONTH
)
SELECT
	CONCAT(YEAR, '-', MONTH) AS YEARMONTH
    , AMOUNT
    , AGG_AMOUNT
    , YEAR_AVG_AMOUNT
FROM CALC_INDEX
WHERE YEAR = '2015'
ORDER BY YEARMONTH;
```

### 매출과 관련된 지표를 집계하는 쿼리 (월 평균 매출, 월 총 매출, 연 매출, 전년 동월 매출, 전년 동월 대비 매출 증감 비율)
```SQL
WITH
DAILY_PURCHASE AS (
	SELECT
		DT
        , SUBSTR(DT, 1, 4) AS YEAR
        , SUBSTR(DT, 6, 2) AS MONTH
        , SUBSTR(DT, 9, 2) AS DATE
        , SUM(PURCHASE_AMOUNT) AS PURCHASE_AMOUNT
	FROM PURCHASE_LOG
    GROUP BY DT
    ORDER BY DT
)
, MONTHLY_PURCHASE AS (
	SELECT
		YEAR
        , MONTH
        , AVG(PURCHASE_AMOUNT) AS AVG_AMOUNT
        , SUM(PURCHASE_AMOUNT) AS MONTHLY
	FROM DAILY_PURCHASE
    GROUP BY YEAR, MONTH
)
SELECT
	CONCAT(YEAR, '-', MONTH) AS YEARMONTH
    , AVG_AMOUNT
    , MONTHLY
    , SUM(MONTHLY) OVER(PARTITION BY YEAR ORDER BY MONTH ROWS UNBOUNDED PRECEDING)
    AS AGG_AMOUNT
    , LAG(MONTHLY, 12) OVER(ORDER BY YEAR, MONTH)
    AS LAST_YEAR
    , 100
      * MONTHLY
      / LAG(MONTHLY, 12) OVER(ORDER BY YEAR, MONTH)
      AS RATE
FROM MONTHLY_PURCHASE
ORDER BY YEARMONTH;
```
