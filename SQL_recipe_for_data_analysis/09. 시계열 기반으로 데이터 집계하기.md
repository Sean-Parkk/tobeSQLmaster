# 08. 여러 개의 테이블 조작하기
> 새로 배운 내용들이 많았음. 특히 WITH문

## 새로 알게된 것
### 상관 서브쿼리
* SELECT문에서 사용하는 서브쿼리 활용법
### 조건 플래그를 0과 1로 표현하는 법
* CASE WHEN 문
* SIGN문 활용
### CTE(Common Table Expression)
* 계산한 테이블에 이름 붙여 다시 사용하기
* WITH TABLE_NAME AS ()

## 쿼리
### 여러 개의 테이블을 세로로 결합하기
```SQL
SELECT 'APP1' AS APP_NAME, USER_ID, NAME, EMAIL FROM APP1_MST_USERS
UNION ALL
SELECT 'APP2' AS APP_NAME, USER_ID, NAME, NULL AS EMAIL FROM APP2_MST_USERS;

/*
* UNION ALL 사용 시에는 컬럼이 동일해야함.
* 컬럼이 다를 경우, 기본값을 지정해서 사용 가능
*/
```

### 여러 개의 테이블을 가로로 정렬하기
```SQL
-- 잘못된 경우
SELECT
	M.CATEGORY_ID
    , M.NAME
    , S.SALES
    , R.PRODUCT_ID AS SALE_PRODUCTS
FROM MST_CATEGORIES AS M
LEFT JOIN CATEGORY_SALES AS S
ON M.CATEGORY_ID = S.CATEGORY_ID
LEFT JOIN PRODUCT_SALE_RANKING AS R
ON M.CATEGORY_ID = R.CATEGORY_ID;
```

### 마스터 테이블 행 수를 변경하지 않고 여러 개의 테이블을 가로로 정렬하는 쿼리
```SQL
SELECT
	M.CATEGORY_ID
    , M.NAME
    , S.SALES
    , R.PRODUCT_ID AS TOP_SALE_PRODUCT
FROM MST_CATEGORIES AS M
LEFT JOIN CATEGORY_SALES AS S
ON M.CATEGORY_ID = S.CATEGORY_ID
LEFT JOIN PRODUCT_SALE_RANKING AS R
ON M.CATEGORY_ID = R.CATEGORY_ID
AND R.RANKING = 1;
```

### 상관 서브쿼리로 여러 테이블을 가로로 정렬
```SQL
SELECT
M.CATEGORY_ID
, M.NAME
, (SELECT S.SALES
	FROM CATEGORY_SALES AS S
    WHERE S.CATEGORY_ID = M.CATEGORY_ID) AS SALES
, (SELECT R.PRODUCT_ID
	FROM PRODUCT_SALE_RANKING AS R
    WHERE M.CATEGORY_ID = R.CATEGORY_ID
    ORDER BY SALES DESC
    LIMIT 1) AS TOP_SALE_PRODUCT
FROM MST_CATEGORIES AS M;
```

### 조건 플래그를 0과 1로 표현하기
```SQL
SELECT
	M.USER_ID
	, M.CARD_NUMBER
    , COUNT(P.AMOUNT) AS PURCHASE_COUNT
    , CASE WHEN M.CARD_NUMBER IS NOT NULL THEN 1 ELSE 0 END AS HAS_CARD
    , CASE WHEN COUNT(M.CARD_NUMBER) > 0 THEN 1 ELSE 0 END AS HAS_CARD_2
	, SIGN(COUNT(P.AMOUNT)) AS HAS_PURCHASED
FROM MST_USERS_WITH_CARD_NUMBER AS M
	LEFT JOIN PURCHASE_LOG AS P
    ON M.USER_ID = P.USER_ID
GROUP BY M.USER_ID;
```

### 계산한 테이블에 이름 붙여 재사용하기
```SQL
WITH
PRODUCT_SALE_RANKING AS (
	SELECT
		CATEGORY_NAME
		, PRODUCT_ID
		, SALES
		, ROW_NUMBER() OVER(PARTITION BY CATEGORY_NAME ORDER BY SALES DESC) AS RANKING
	FROM PRODUCT_SALES
)
SELECT * FROM PRODUCT_SALE_RANKING;
```

### 계산한 테이블에 이름 붙여 재사용하기 2
```SQL
WITH
PRODUCT_SALE_RANKING AS (
	SELECT
		CATEGORY_NAME
		, PRODUCT_ID
		, SALES
		, ROW_NUMBER() OVER(PARTITION BY CATEGORY_NAME ORDER BY SALES DESC) AS RANKING
	FROM PRODUCT_SALES
)
, MST_RANK AS (
	SELECT DISTINCT RANKING
    FROM PRODUCT_SALE_RANKING
)
SELECT * FROM MST_RANK;
```

### 계산한 테이블에 이름 붙여 재사용하기 3
```SQL
WITH
PRODUCT_SALE_RANKING AS (
	SELECT
		CATEGORY_NAME
		, PRODUCT_ID
		, SALES
		, ROW_NUMBER() OVER(PARTITION BY CATEGORY_NAME ORDER BY SALES DESC) AS RANKING
	FROM PRODUCT_SALES
)
, MST_RANK AS (
	SELECT DISTINCT RANKING
    FROM PRODUCT_SALE_RANKING
)

SELECT
	M.RANKING
    , R1.PRODUCT_ID AS DVD
    , R1.SALES AS DVD_SALES
	, R2.PRODUCT_ID AS CD
    , R2.SALES AS CD_SALES
    , R3.PRODUCT_ID AS BOOK
    , R3.SALES AS BOOK_SALES
FROM
	MST_RANK AS M
    LEFT JOIN
		PRODUCT_SALE_RANKING AS R1
        ON M.RANKING = R1.RANKING
        AND R1.CATEGORY_NAME = 'DVD'
	LEFT JOIN
		PRODUCT_SALE_RANKING AS R2
        ON M.RANKING = R2.RANKING
        AND R2.CATEGORY_NAME = 'CD'
	LEFT JOIN
		PRODUCT_SALE_RANKING AS R3
        ON M.RANKING = R3.RANKING
        AND R3.CATEGORY_NAME = 'BOOK'
ORDER BY M.RANKING;
```

### 임의의 레코드를 가진 유사 테이블 만들기
```SQL
WITH
MST_DEVICES AS (
			  SELECT 1 AS DEVICE_ID, 'PC' AS DEVICE_NAME
    UNION ALL SELECT 2 AS DEVICE_ID, 'SP' AS DEVICE_NAME
    UNION ALL SELECT 3 AS DEVICE_ID, 'APP' AS DEVICE_NAME
)
SELECT * FROM MST_DEVICES;
```

### 의사 테이블을 사용해 코드를 레이블로 변환하는 쿼리
```SQL
WITH
MST_DEVICES AS (
			  SELECT 1 AS DEVICE_ID, 'PC' AS DEVICE_NAME
    UNION ALL SELECT 2 AS DEVICE_ID, 'SP' AS DEVICE_NAME
    UNION ALL SELECT 3 AS DEVICE_ID, 'APP' AS DEVICE_NAME
)
SELECT
	U.USER_ID
    , D.DEVICE_NAME
FROM
	MST_USERS AS U
    LEFT JOIN
		MST_DEVICES AS D
        ON U.REGISTER_DEVICE = D.DEVICE_ID;
```
