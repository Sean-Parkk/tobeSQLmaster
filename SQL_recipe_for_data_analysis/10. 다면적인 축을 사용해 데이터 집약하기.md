# 10. 다면적인 축을 사용해 데이터 집약하기
> 매출 데이터를 다양한 방면으로 분석하는 쿼리

## 새로 알게된 것
### ROLLUP(COL1, COL2)
* COL1, COL2...등으로 집계 그룹 만들어줌.
	* ```SQL
			-- MYSQL
			GROUP BY COL WITH ROLLUP
		```
	* 피벗테이블처럼!
* 도수분포표 in SQL!


## 쿼리
### 카테고리별 매출과 소계 계산하기
```SQL
-- 이 방법은 테이블을 여러 번 부르고, 데이터 결합 비용도 발생하여 성능이 안 좋음.
WITH
	SUB_CATEGORY_AMOUNT AS (
		-- 소 카테고리의 매출 집계
		SELECT
			CATEGORY
			, SUB_CATEGORY
			, SUM(PRICE) AS AMOUNT
		FROM PURCHASE_DETAIL_LOG
		GROUP BY CATEGORY, SUB_CATEGORY
	)
	, CATEGORY_AMOUNT AS (
		SELECT
			CATEGORY
            , 'ALL' AS SUB_CATEGORY
            , SUM(PRICE) AS AMOUNT
		FROM PURCHASE_DETAIL_LOG
        GROUP BY CATEGORY
	)
    , TOTAL_AMOUNT AS (
		SELECT
			'ALL' AS CATEGORY
            , 'ALL' AS SUB_CATEGORY
            , SUM(PRICE) AS AMOUNT
		FROM
			PURCHASE_DETAIL_LOG
	)
		  SELECT CATEGORY, SUB_CATEGORY, AMOUNT FROM SUB_CATEGORY_AMOUNT
UNION ALL SELECT CATEGORY, SUB_CATEGORY, AMOUNT FROM CATEGORY_AMOUNT
UNION ALL SELECT CATEGORY, SUB_CATEGORY, AMOUNT FROM TOTAL_AMOUNT;
```

### ROLLUP을 사용하여 카테고리별 매출과 소계를 구하는 쿼리
```SQL
SELECT
	-- ROLLUP사용 시, 집계 행은 NULL값이 되므로 이를 COALESCE를 통해 값 변환
    COALESCE(CATEGORY, 'ALL') AS CATEGORY
    , COALESCE(SUB_CATEGORY, 'ALL') AS SUB_CATEGORY
    , SUM(PRICE) AS AMOUNT
FROM
	PURCHASE_DETAIL_LOG
GROUP BY
	CATEGORY, SUB_CATEGORY WITH ROLLUP;

### ABC 분석으로 잘 팔리는 상품 판별하기
WITH
	MONTHLY_SALES AS (
		SELECT
			CATEGORY
            , SUM(PRICE) AS AMOUNT
		FROM PURCHASE_DETAIL_LOG
        GROUP BY CATEGORY
	)
    , SALES_COMPOSITION_RATIO AS (
		SELECT
			CATEGORY
            , AMOUNT
            , 100 * AMOUNT / SUM(AMOUNT) OVER() AS COMPOSITION_RATIO
            , 100 * SUM(AMOUNT) OVER(ORDER BY AMOUNT DESC)
            / SUM(AMOUNT) OVER() AS CUMULATIVE_RATIO
		FROM MONTHLY_SALES
	)
SELECT
	*
    , CASE
		WHEN CUMULATIVE_RATIO BETWEEN 0 AND 70 THEN 'A'
        WHEN CUMULATIVE_RATIO BETWEEN 70 AND 90 THEN 'B'
        WHEN CUMULATIVE_RATIO BETWEEN 90 AND 100 THEN 'C'
	END AS ABC_RANK
FROM SALES_COMPOSITION_RATIO
ORDER BY AMOUNT DESC;
```

### 팬 차트로 상품의 매출 증가율 확인하기
```SQL
WITH
	DAILY_CATEGORY_AMOUNT AS (
		SELECT
			DT
            , CATEGORY
            , SUBSTR(DT, 1, 4) AS YEAR
            , SUBSTR(DT, 6, 2) AS MONTH
            , SUBSTR(DT, 9, 2) AS DATE
            , SUM(PRICE) AS AMOUNT
		FROM PURCHASE_DETAIL_LOG
        GROUP BY DT, CATEGORY
)
, MONTHLY_CATEGORY_AMOUNT AS (
	SELECT
		CONCAT(YEAR, '-', MONTH) AS YEARMONTH
        , CATEGORY
        , SUM(AMOUNT) AS AMOUNT
	FROM DAILY_CATEGORY_AMOUNT
    GROUP BY YEAR, MONTH, CATEGORY
)
SELECT
	YEARMONTH
    , CATEGORY
    , AMOUNT
    , FIRST_VALUE(AMOUNT)
		OVER(PARTITION BY CATEGORY ORDER BY YEARMONTH, CATEGORY ROWS UNBOUNDED PRECEDING)
	  AS BASE_AMOUNT
    , 100
      * AMOUNT
      / FIRST_VALUE(AMOUNT)
		OVER(PARTITION BY CATEGORY ORDER BY YEARMONTH, CATEGORY ROWS UNBOUNDED PRECEDING)
	  AS RATE
FROM MONTHLY_CATEGORY_AMOUNT
ORDER BY YEARMONTH, CATEGORY;
```

### 히스토그램으로 구매 가격대 집계하기 - 데이터의 통계량, 범위
```SQL
WITH
STATS AS (
	SELECT
		MAX(PRICE)+1 AS MAX_PRICE
        , MIN(PRICE) AS MIN_PRICE
        , MAX(PRICE)+1 - MIN(PRICE) AS RANGE_PRICE
        , 10 AS BUCKET_NUM
	FROM PURCHASE_DETAIL_LOG
)
SELECT *
FROM STATS;
```

### 데이터 계층 구하기
```SQL
WITH
STATS AS (
	SELECT
		MAX(PRICE) + 1 AS MAX_PRICE
        , MIN(PRICE) AS MIN_PRICE
        , MAX(PRICE) + 1 - MIN(PRICE) AS RANGE_PRICE
        , 10 AS BUCKET_NUM
	FROM PURCHASE_DETAIL_LOG
)
, PURCHASE_LOG_WITH_BUCKET AS (
	SELECT
		PRICE
        , MIN_PRICE
        , PRICE - MIN_PRICE AS DIFF
        , FLOOR(RANGE_PRICE / BUCKET_NUM) AS BUCKET_RANGE
        , FLOOR(
		  (PRICE - MIN_PRICE)
		  / (RANGE_PRICE / BUCKET_NUM)
          )+ 1 AS BUCKET
	FROM PURCHASE_DETAIL_LOG, STATS
)
SELECT *
FROM PURCHASE_LOG_WITH_BUCKET
ORDER BY PRICE;
```

### 도수분포표 구하기
```SQL
WITH
STATS AS (
	SELECT
		MAX(PRICE) + 1 AS MAX_PRICE
        , MIN(PRICE) AS MIN_PRICE
        , MAX(PRICE) + 1 - MIN(PRICE) AS RANGE_PRICE
        , 10 AS BUCKET_NUM
	FROM PURCHASE_DETAIL_LOG
)
, PURCHASE_LOG_WITH_BUCKET AS (
	SELECT
		PRICE
        , MIN_PRICE
        , PRICE - MIN_PRICE AS DIFF
        , FLOOR(RANGE_PRICE / BUCKET_NUM) AS BUCKET_RANGE
        , FLOOR(
		  (PRICE - MIN_PRICE)
		  / (RANGE_PRICE / BUCKET_NUM)
          )+ 1 AS BUCKET
	FROM PURCHASE_DETAIL_LOG, STATS
)
SELECT
	BUCKET
    , MIN_PRICE + BUCKET_RANGE * (BUCKET - 1) AS LOWER_LIMIT
    , MIN_PRICE + BUCKET_RANGE * BUCKET AS UPPER_LIMIT
    , COUNT(PRICE) AS NUM_PURCHASE
    , SUM(PRICE) AS TOTAL_AMOUNT
FROM PURCHASE_LOG_WITH_BUCKET
GROUP BY BUCKET, MIN_PRICE, BUCKET_RANGE
ORDER BY BUCKET;
```

### 임의의 계층 너비로 도수분포표 작성하기
```SQL
WITH
	STATS AS (
		SELECT
			150000 AS MAX_PRICE
            , 10000 AS MIN_PRICE
            , 150000 AS RANGE_PRICE
            , 10 AS BUCKET_NUM
		FROM
			PURCHASE_DETAIL_LOG
	)
    , PURCHASE_LOG_WITH_BUCKET AS (
		SELECT
			PRICE
			, MIN_PRICE
			, PRICE - MIN_PRICE AS DIFF
			, FLOOR(RANGE_PRICE / BUCKET_NUM) AS BUCKET_RANGE
			, FLOOR(
			  (PRICE - MIN_PRICE)
			  / (RANGE_PRICE / BUCKET_NUM)
			  )+ 1 AS BUCKET
		FROM PURCHASE_DETAIL_LOG, STATS
	)
SELECT
	BUCKET
    , MIN_PRICE + BUCKET_RANGE * (BUCKET - 1) AS LOWER_LIMIT
    , MIN_PRICE + BUCKET_RANGE * BUCKET AS UPPER_LIMIT
    , COUNT(PRICE) AS NUM_PURCHASE
    , SUM(PRICE) AS TOTAL_AMOUNT
    FROM PURCHASE_LOG_WITH_BUCKET
    GROUP BY BUCKET, MIN_PRICE, BUCKET_RANGE
    ORDER BY BUCKET;
```
