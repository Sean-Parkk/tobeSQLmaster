### 액션과 관련된 지표 집계하기
WITH
	STATS AS (
		SELECT COUNT(DISTINCT SESSION) AS TOTAL_UU
        FROM ACTION_LOG
	)
SELECT
	L.ACTION
    , COUNT(DISTINCT L.SESSION) AS ACTION_UU
    , COUNT(*) AS ACTION_COUNT
    , S.TOTAL_UU
    , 100
      * COUNT(DISTINCT L.SESSION)
      / S.TOTAL_UU
      AS USAGE_RATE
	, COUNT(*)
      / COUNT(DISTINCT L.SESSION)
      AS COUNT_PER_USER
FROM ACTION_LOG AS L
CROSS JOIN STATS AS S
GROUP BY L.ACTION, S.TOTAL_UU;

### 로그인 사용자와 비로그인 사용자 구분하여 집계하기
WITH
	ACTION_LOG_WITH_STATUS AS (
		SELECT
			SESSION
            , USER_ID
            , ACTION
            , CASE WHEN COALESCE(USER_ID, '') <> '' THEN 'login' ELSE 'guest' END
              AS LOGIN_STATUS
		FROM ACTION_LOG
)
SELECT * FROM ACTION_LOG_WITH_STATUS;

## 로그인 상태에 따라 액션 수 등을 따로 집계하는 쿼리 (WITH ROLLUP)
WITH
	ACTION_LOG_WITH_STATUS AS (
		SELECT
			SESSION
            , USER_ID
            , ACTION
            , CASE WHEN COALESCE(USER_ID, '') <> '' THEN 'login' ELSE 'guest' END AS LOGIN_STATUS
		FROM ACTION_LOG
	)
SELECT
	COALESCE(ACTION, 'all') AS ACTION
    , COALESCE(LOGIN_STATUS, 'all') AS LOGIN_STATUS
    , COUNT(DISTINCT SESSION) AS ACTION_UU
    , COUNT(*) AS ACTION_COUNT
FROM ACTION_LOG_WITH_STATUS
GROUP BY ACTION, LOGIN_STATUS WITH ROLLUP;

### 회원과 비회원을 구분해서 집계하기
WITH
	ACTION_LOG_WITH_STATUS AS (
		SELECT
			SESSION
            , USER_ID
            , ACTION
            , CASE
				WHEN COALESCE(MAX(USER_ID)
								OVER(PARTITION BY SESSION ORDER BY STAMP
									ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
							  , '') <> ''
			  THEN 'member'
              ELSE 'none'
            END AS MEMBER_STATUS
            , STAMP
		FROM ACTION_LOG
	)
SELECT * FROM ACTION_LOG_WITH_STATUS;

### 사용자의 생일로 나이를 계산하는 쿼리
WITH
	MST_USERS_WITH_INT_BIRTH_DATE AS (
		SELECT
			*
            , 20200728 AS TODAY
            , REPLACE(BIRTH_DATE, '-', '') AS INT_BIRTH_DATE
		FROM MST_USERS
	)
, MST_USER_WITH_AGE AS (
	SELECT
    *
	, FLOOR((TODAY - INT_BIRTH_DATE) / 10000) AS AGE
	FROM MST_USERS_WITH_INT_BIRTH_DATE
)
SELECT
USER_ID
, SEX
, BIRTH_DATE
, AGE FROM MST_USER_WITH_AGE;

### 성별과 연령으로 연령별 구분을 계산하는 쿼리
WITH
	MST_USERS_WITH_INT_BIRTH_DATE AS (
		SELECT
			*
            , 20200728 AS TODAY
            , REPLACE(BIRTH_DATE, '-', '') AS INT_BIRTH_DATE
		FROM MST_USERS
	)
, MST_USER_WITH_AGE AS (
	SELECT
    *
	, FLOOR((TODAY - INT_BIRTH_DATE) / 10000) AS AGE
	FROM MST_USERS_WITH_INT_BIRTH_DATE
)
, MST_USERS_WITH_CATEGORY AS (
	SELECT
	USER_ID
	, SEX
	, AGE
	, CONCAT(
		CASE
			WHEN AGE >= 20 THEN SEX
			ELSE ''
		END
		, CASE
			WHEN AGE BETWEEN 4 AND 12 THEN 'C'
			WHEN AGE BETWEEN 13 AND 19 THEN 'T'
			WHEN AGE BETWEEN 20 AND 34 THEN '1'
			WHEN AGE BETWEEN 35 AND 49 THEN '2'
			WHEN AGE >= 50 THEN '3'
		END
		) AS CATEGORY
	FROM MST_USER_WITH_AGE
)
SELECT * FROM MST_USERS_WITH_CATEGORY;

### 연령별 구분의 사람 수를 계산하는 쿼리
WITH
	MST_USERS_WITH_INT_BIRTH_DATE AS (
		SELECT
			*
            , 20200728 AS TODAY
            , REPLACE(BIRTH_DATE, '-', '') AS INT_BIRTH_DATE
		FROM MST_USERS
	)
, MST_USER_WITH_AGE AS (
	SELECT
    *
	, FLOOR((TODAY - INT_BIRTH_DATE) / 10000) AS AGE
	FROM MST_USERS_WITH_INT_BIRTH_DATE
)
, MST_USERS_WITH_CATEGORY AS (
	SELECT
	USER_ID
	, SEX
	, AGE
	, CONCAT(
		CASE
			WHEN AGE >= 20 THEN SEX
			ELSE ''
		END
		, CASE
			WHEN AGE BETWEEN 4 AND 12 THEN 'C'
			WHEN AGE BETWEEN 13 AND 19 THEN 'T'
			WHEN AGE BETWEEN 20 AND 34 THEN '1'
			WHEN AGE BETWEEN 35 AND 49 THEN '2'
			WHEN AGE >= 50 THEN '3'
		END
		) AS CATEGORY
	FROM MST_USER_WITH_AGE
)
SELECT
	CATEGORY
    , COUNT(*) AS USER_COUNT
FROM MST_USERS_WITH_CATEGORY
GROUP BY CATEGORY;

### 연령별 구분의 특징 추출하기
WITH
	MST_USERS_WITH_INT_BIRTH_DATE AS (
		SELECT
			*
            , 20200728 AS TODAY
            , REPLACE(BIRTH_DATE, '-', '') AS INT_BIRTH_DATE
		FROM MST_USERS
	)
, MST_USER_WITH_AGE AS (
	SELECT
    *
	, FLOOR((TODAY - INT_BIRTH_DATE) / 10000) AS AGE
	FROM MST_USERS_WITH_INT_BIRTH_DATE
)
, MST_USERS_WITH_CATEGORY AS (
	SELECT
	USER_ID
	, SEX
	, AGE
	, CONCAT(
		CASE
			WHEN AGE >= 20 THEN SEX
			ELSE ''
		END
		, CASE
			WHEN AGE BETWEEN 4 AND 12 THEN 'C'
			WHEN AGE BETWEEN 13 AND 19 THEN 'T'
			WHEN AGE BETWEEN 20 AND 34 THEN '1'
			WHEN AGE BETWEEN 35 AND 49 THEN '2'
			WHEN AGE >= 50 THEN '3'
		END
		) AS CATEGORY
	FROM MST_USER_WITH_AGE
)
SELECT
	A.CATEGORY AS PRODUCT_CATEGORY
    , M.CATEGORY AS USER_CATEGORY
    , COUNT(*) AS PURCHASE_COUNT
FROM ACTION_LOG AS A
JOIN MST_USERS_WITH_CATEGORY AS M
	ON A.USER_ID = M.USER_ID
WHERE A.ACTION = 'purchase'
GROUP BY A.CATEGORY, M.CATEGORY
ORDER BY A.CATEGORY, M.CATEGORY;

SELECT ACTION_LOG;
### 사용자의 방문 빈도 집계하기
WITH
	ACTION_LOG_WITH_DT AS (
		SELECT
			*
            , SUBSTR(STAMP, 1, 10) AS DT
		FROM ACTION_LOG
	)
    , ACTION_DAY_COUNT_PER_USER AS (
		SELECT
			USER_ID
            , COUNT(DISTINCT DT) AS ACTION_DAY_COUNT
		FROM ACTION_LOG_WITH_DT

		GROUP BY
			USER_ID
	)
SELECT
	ACTION_DAY_COUNT
    , COUNT(DISTINCT USER_ID) AS USER_COUNT
FROM ACTION_DAY_COUNT_PER_USER
GROUP BY 1
ORDER BY 1;

### 구성비와 구성비 누계 계산
WITH
	ACTION_LOG_WITH_DT AS (
		SELECT
			*
			, SUBSTR(STAMP, 1, 10) AS DT
		FROM ACTION_LOG
        )
	, ACTION_DAY_COUNT_PER_USER AS (
		SELECT
			USER_ID
            , COUNT(DISTINCT DT) AS ACTION_DAY_COUNT
		FROM ACTION_LOG_WITH_DT
        WHERE DT BETWEEN '2016-11-01' AND '2016-11-07'
        GROUP BY USER_ID
	)
SELECT
	ACTION_DAY_COUNT
    , COUNT(DISTINCT USER_ID) AS USER_COUNT
    , 100
      * COUNT(DISTINCT USER_ID)
      / SUM(COUNT(DISTINCT USER_ID)) OVER()
      AS CUMULATIVE_RATIO
	, 100
	  * SUM(COUNT(DISTINCT USER_ID))
			OVER(ORDER BY ACTION_DAY_COUNT
				ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
	  / SUM(COUNT(DISTINCT USER_ID)) OVER()
      AS CUMULATIVE_RATIO

FROM ACTION_DAY_COUNT_PER_USER
GROUP BY ACTION_DAY_COUNT
ORDER BY ACTION_DAY_COUNT;

### 벤 다이어그램으로 사용자 액션 집계하기
WITH
	USER_ACTION_FLAG AS (
		SELECT
			USER_ID
            , SIGN(SUM(CASE WHEN ACTION = 'PURCHASE' THEN 1 ELSE 0 END)) AS HAS_PURCHASE
            , SIGN(SUM(CASE WHEN ACTION = 'REVIEW' THEN 1 ELSE 0 END)) AS HAS_REVIEW
            , SIGN(SUM(CASE WHEN ACTION = 'FAVORITE' THEN 1 ELSE 0 END)) AS HAS_FAVORITE
		FROM ACTION_LOG
        GROUP BY USER_ID
	)
SELECT * FROM USER_ACTION_FLAG;

### Decile 분석을 사용해 사용자를 10단계 그룹으로 나누기
WITH
	USER_PURCHASE_AMOUNT AS (
		SELECT
			USER_ID
            , SUM(AMOUNT) AS PURCHASE_AMOUNT
		FROM ACTION_LOG
        WHERE UPPER(ACTION) = 'PURCHASE'
        GROUP BY USER_ID
        )
	, USERS_WITH_DECILE AS (
		SELECT
			USER_ID
            , PURCHASE_AMOUNT
            , NTILE(10) OVER (ORDER BY PURCHASE_AMOUNT DESC) AS DECILE
		FROM USER_PURCHASE_AMOUNT
	)

SELECT * FROM USERS_WITH_DECILE;

### 10분할한 Decile들을 집계하는 쿼리
WITH
	USER_PURCHASE_AMOUNT AS (
		SELECT
			USER_ID
            , SUM(AMOUNT) AS PURCHASE_AMOUNT
		FROM ACTION_LOG
        WHERE UPPER(ACTION) = 'PURCHASE'
        GROUP BY USER_ID
        )
	, USERS_WITH_DECILE AS (
		SELECT
			USER_ID
            , PURCHASE_AMOUNT
            , NTILE(10) OVER (ORDER BY PURCHASE_AMOUNT DESC) AS DECILE
		FROM USER_PURCHASE_AMOUNT
	)
    , DECILE_WITH_PURCHASE_AMOUNT AS (
		SELECT
			DECILE
            , SUM(PURCHASE_AMOUNT) AS AMOUNT
            , AVG(PURCHASE_AMOUNT) AS AVG_AMOUNT
            , SUM(SUM(PURCHASE_AMOUNT)) OVER(ORDER BY DECILE) AS CUMULATIVE_AMOUNT
            , SUM(SUM(PURCHASE_AMOUNT)) OVER() AS TOTAL_AMOUNT
		FROM USERS_WITH_DECILE
        GROUP BY DECILE
	)
SELECT * FROM DECILE_WITH_PURCHASE_AMOUNT;

### 구매액이 많은 DECILE 순서로 구성비와 구성비누계를 계산하는 쿼리
WITH
	USER_PURCHASE_AMOUNT AS (
		SELECT
			USER_ID
            , SUM(AMOUNT) AS PURCHASE_AMOUNT
		FROM ACTION_LOG
        WHERE UPPER(ACTION) = 'PURCHASE'
        GROUP BY USER_ID
        )
	, USERS_WITH_DECILE AS (
		SELECT
			USER_ID
            , PURCHASE_AMOUNT
            , NTILE(10) OVER (ORDER BY PURCHASE_AMOUNT DESC) AS DECILE
		FROM USER_PURCHASE_AMOUNT
	)
    , DECILE_WITH_PURCHASE_AMOUNT AS (
		SELECT
			DECILE
            , SUM(PURCHASE_AMOUNT) AS AMOUNT
            , AVG(PURCHASE_AMOUNT) AS AVG_AMOUNT
            , SUM(SUM(PURCHASE_AMOUNT)) OVER(ORDER BY DECILE) AS CUMULATIVE_AMOUNT
            , SUM(SUM(PURCHASE_AMOUNT)) OVER() AS TOTAL_AMOUNT
		FROM USERS_WITH_DECILE
        GROUP BY DECILE
	)
	SELECT
		DECILE
        , AMOUNT
        , AVG_AMOUNT
        , 100 * AMOUNT / TOTAL_AMOUNT AS TOTAL_RATIO
        , 100 * CUMULATIVE_AMOUNT / TOTAL_AMOUNT AS CUMULATIVE_RATIO
	FROM DECILE_WITH_PURCHASE_AMOUNT;

### RFM 분석의 3가지 지표 집계하기
WITH
	PURCHASE_LOG AS (
		SELECT
			USER_ID
            , AMOUNT
            , SUBSTR(STAMP, 1, 10) AS DT
		FROM ACTION_LOG
        WHERE ACTION = 'PURCHASE'
	)
    , USER_RFM AS (
		SELECT
			USER_ID
            , MAX(DT) AS RECENT_DATE
            , DATEDIFF(CURRENT_DATE(), MAX(DT)) AS RECENCY
            , COUNT(DT) AS FREQUENCY
            , SUM(AMOUNT) AS MONETARY
		FROM PURCHASE_LOG
        GROUP BY USER_ID
	)
SELECT * FROM USER_RFM;

### RFM 랭크 정의하기
WITH
	PURCHASE_LOG AS (
		SELECT
			USER_ID
            , AMOUNT
            , SUBSTR(STAMP, 1, 10) AS DT
		FROM ACTION_LOG
        WHERE ACTION = 'PURCHASE'
	)
    , USER_RFM AS (
		SELECT
			USER_ID
            , MAX(DT) AS RECENT_DATE
            , DATEDIFF(CURRENT_DATE(), MAX(DT)) AS RECENCY
            , COUNT(DT) AS FREQUENCY
            , SUM(AMOUNT) AS MONETARY
		FROM PURCHASE_LOG
        GROUP BY USER_ID
	)
	, USER_RFM_RANK AS (
		SELECT
			USER_ID
            , RECENT_DATE
            , RECENCY
            , FREQUENCY
            , MONETARY
            , CASE
				WHEN RECENCY < 14 THEN 5
                WHEN RECENCY < 28 THEN 4
                WHEN RECENCY < 60 THEN 3
                WHEN RECENCY < 90 THEN 2
                ELSE 1
			  END AS R
            , CASE
				WHEN 20 <= FREQUENCY THEN 5
                WHEN 10 <= FREQUENCY THEN 5
                WHEN 5 <= FREQUENCY THEN 5
                WHEN 2 <= FREQUENCY THEN 5
                ELSE 1
			  END AS F
			, CASE
				WHEN 3000000 <= MONETARY THEN 5
                WHEN 1000000 <= MONETARY THEN 5
                WHEN 300000 <= MONETARY THEN 5
                WHEN 50000 <= MONETARY THEN 5
                ELSE 1
			  END AS M
		FROM USER_RFM
	)
SELECT * FROM USER_RFM_RANK;

### 각 그룹의 사람 수를 확인하는 쿼리
WITH
	PURCHASE_LOG AS (
		SELECT
			USER_ID
            , AMOUNT
            , SUBSTR(STAMP, 1, 10) AS DT
		FROM ACTION_LOG
        WHERE ACTION = 'PURCHASE'
	)
    , USER_RFM AS (
		SELECT
			USER_ID
            , MAX(DT) AS RECENT_DATE
            , DATEDIFF(CURRENT_DATE(), MAX(DT)) AS RECENCY
            , COUNT(DT) AS FREQUENCY
            , SUM(AMOUNT) AS MONETARY
		FROM PURCHASE_LOG
        GROUP BY USER_ID
	)
	, USER_RFM_RANK AS (
		SELECT
			USER_ID
            , RECENT_DATE
            , RECENCY
            , FREQUENCY
            , MONETARY
            , CASE
				WHEN RECENCY < 14 THEN 5
                WHEN RECENCY < 28 THEN 4
                WHEN RECENCY < 60 THEN 3
                WHEN RECENCY < 90 THEN 2
                ELSE 1
			  END AS R
            , CASE
				WHEN 20 <= FREQUENCY THEN 5
                WHEN 10 <= FREQUENCY THEN 5
                WHEN 5 <= FREQUENCY THEN 5
                WHEN 2 <= FREQUENCY THEN 5
                ELSE 1
			  END AS F
			, CASE
				WHEN 3000000 <= MONETARY THEN 5
                WHEN 1000000 <= MONETARY THEN 5
                WHEN 300000 <= MONETARY THEN 5
                WHEN 50000 <= MONETARY THEN 5
                ELSE 1
			  END AS M
		FROM USER_RFM
	)
    , MST_RFM_INDEX AS (
		SELECT 1 AS RFM_INDEX
        UNION ALL SELECT 2 AS RFM_INDEX
        UNION ALL SELECT 3 AS RFM_INDEX
        UNION ALL SELECT 4 AS RFM_INDEX
        UNION ALL SELECT 5 AS RFM_INDEX
	)
    , RFM_FLAG AS (
		SELECT
			M.RFM_INDEX
            , CASE WHEN M.RFM_INDEX = R.R THEN 1 ELSE 0 END AS R_FLAG
            , CASE WHEN M.RFM_INDEX = R.F THEN 1 ELSE 0 END AS F_FLAG
            , CASE WHEN M.RFM_INDEX = R.M THEN 1 ELSE 0 END AS M_FLAG
		FROM MST_RFM_INDEX AS M
			CROSS JOIN
				USER_RFM_RANK AS R
	)
SELECT
	RFM_INDEX
    , SUM(R_FLAG) AS R
    , SUM(F_FLAG) AS F
    , SUM(M_FLAG) AS M
FROM RFM_FLAG
GROUP BY RFM_INDEX
ORDER BY RFM_INDEX;

        
